<!DOCTYPE html>
<html>

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
<meta charset="utf-8" />
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
<title>Khoa học dữ liệu</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> 
<link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300" rel="stylesheet">
<!-- <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> -->
<link href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Fira+Sans" rel="stylesheet">
<link rel="icon" type="image/jpg" href="assets/images/logo.jpg" sizes="32x32">
<link rel="canonical" href="https://phamdinhkhanh.github.io"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="author" content="Phạm Đình Khánh" />
<meta property="og:title" content="" />
<meta property="og:site_name" content="Khanh's blog" />
<meta property="og:url" content="https://phamdinhkhanh.github.io" />
<meta property="og:description" content="" />

<meta property="og:type" content="article" />
<meta property="article:published_time" content="" />


<meta property="article:author" content="Khanh" />
<meta property="article:section" content="" />

<link rel="alternate" type="application/atom+xml" title="Khanh's blog - Atom feed" href="/feed.xml" />

<!-- Style for main home page -->
<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/styles_toc.css">

<style>
	
</style>
<!-- -- Import latext  -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
	skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
	inlineMath: [['$','$']]
  }
});
</script>

<!-- Google Analytics -->

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-89509207-1', 'auto');
// ga('send', 'pageview');
ga('send', 'pageview', {
'page': '/',
'title': ''
});
</script>


<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KTCD8BX');</script>
<!-- End Google Tag Manager -->
</head>
<style>
body {
  padding: 0 7.5%;
}
</style>

<body>
	<div id="fb-root"></div>
	<!-- <script>(function(d, s, id) { -->
	  <!-- var js, fjs = d.getElementsByTagName(s)[0]; -->
	  <!-- if (d.getElementById(id)) return; -->
	  <!-- js = d.createElement(s); js.id = id; -->
	  <!-- js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.9"; -->
	  <!-- fjs.parentNode.insertBefore(js, fjs); -->
	<!-- }(document, 'script', 'facebook-jssdk'));</script> -->
	<br>
	<div content = "container">
		<div class="row">
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/img.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Latest</div>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/28/deployTensorflowJS.html">Bài 30 - Xây dựng Web AI trên tensorflow js</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/23/FlaskRestAPI.html">Bài 29 - Xây dựng Flask API cho mô hình deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/21/faceNet.html">Bài 28 - Thực hành training Facenet</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/12/faceNetAlgorithm.html">Bài 27 - Mô hình Facenet trong face recognition</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/10/DarknetGoogleColab.html">Bài 26 - Huấn luyện YOLO darknet trên google colab</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/09/DarknetAlgorithm.html">Bài 25 - YOLO You Only Look Once</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/17/ImbalancedData.html">Bài 24 - Mất cân bằng dữ liệu (imbalanced dataset)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/11/NARSyscom2015.html">Bài 23 - Neural Attentive Session-Based Recommendation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/17/ScoreCard.html">Bài 22 - Scorecard model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/06/ImagePreprocessing.html">Bài 21 - Tiền xử lý ảnh OpenCV</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/26/Sorfmax_Recommendation_Neural_Network.html">Bài 20 - Recommendation Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/12/ARIMAmodel.html">Bài 19 - Mô hình ARIMA trong time series</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/02/DeepLearningLayer.html">Bài 18 - Các layers quan trọng trong deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/22/HOG.html">Bài 17 - Thuật toán HOG (Histrogram of oriented gradient)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/08/RFMModel.html">Bài 16 - Model RFM phân khúc khách hàng</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/04/Recommendation_Compound_Part1.html">Bài 15 - collaborative và content-based filtering</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/22/googleHeatmap.html">Bài 14 - Biểu đồ trên Google Map</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/05/SSDModelObjectDetection.html">Bài 13 - Model SSD trong Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/29/OverviewObjectDetection.html">Bài 12 - Các thuật toán Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/16/VisualizationPython.html">Bài 11 - Visualization trong python</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/08/LDATopicModel.html">Bài 10 - Thuật toán LDA - Xác định Topic</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/25/PyTorch_Torchtext_Tutorial.html">Bài 9 - Pytorch - Buổi 3 - torchtext module NLP</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/19/CorrectSpellingVietnamseTonePrediction.html">Bài 7 - Pytorch - Buổi 2 - Seq2seq model correct spelling</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/10/PytorchTurtorial1.html">Bài 6 - Pytorch - Buổi 1 - Làm quen với pytorch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/07/15/PySparkSQL.html">Bài 5 - Model Pipeline - SparkSQL</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/06/18/AttentionLayer.html">Bài 4 -  Attention is all you need</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/05/10/Hypothesis_Statistic.html">Apenddix 1 - Lý thuyết phân phối và kiểm định thống kê</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/29/ModelWord2Vec.html">Bài 3 - Mô hình Word2Vec</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/22/Ly_thuyet_ve_mang_LSTM.html">Bài 2 - Lý thuyết về mạng LSTM part 2</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/01/07/Ky_thuat_feature_engineering.html">Bài 1 - Kĩ thuật feature engineering</a></li>
					
				</nav>
			</div>
			<div class="col-md-8 col-xs-12" style="z-index:1">
				<nav class="navbar navbar-inverse" style="background-color: #046897">
					<div class = "container-fluid">
						<div class = "navbar-header>
							<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
							</button>
							<a class="navbar-brand" href="/">
								<span style="color:#FFF">Khoa học dữ liệu - Khanh's blog</span>
							</a>
						</div>
						<br>
						<br>
						<div class="collapse navbar-collapse navbar-right" id="myNavbar">
							<ul class="nav navbar-nav">
								<li><a href="/home"><span style="color: #fff"> Home</span></a></li>
								<li><a href="/about"><span style="color: #fff"> About</span></a></li>
								<!-- <li><a href="/da"><span style="color: #fff">Data Analytics</span></a></li> -->
								<!-- <li><a href="/cv"><span style="color: #fff">Computer Vision</span></a></li> -->
								<!-- <li><a href="/nlp"><span style="color: #fff">NLP</span></a></li> -->
								<!-- <li><a href="/code"><span style="color: #fff">Code</span></a></li> -->
								<li><a href="/book"><span style="color: #fff">Book</span></a></li>
							</ul>
						</div>
					</div>
				</nav>
				<div class="PageNavigation">
				</div>
				<h1 itemprop="name" class="post-title"></h1>
				<div>
					<div>
<h2><p class="post-link" style="text-align: left; color: #204081; font-weight: bold">Bài 30 - Xây dựng Web AI trên tensorflow js</p></h2> 
<strong>28 Mar 2020 - phamdinhkhanh</strong>
</div>
<br/>
<div id="toc"></div>
<h1 id="1-giới-thiệu-chung">1. Giới thiệu chung</h1>

<p>Ở <a href="https://phamdinhkhanh.github.io/2020/03/23/FlaskRestAPI.html">bài trước</a> mình đã giới thiệu với các bạn cách nào để xây dựng được một API và vai trò của API đối với hoạt động của các ứng dụng.</p>

<p>Tiếp nối bài trước, ở bài này mình sẽ hướng dẫn mọi người làm thể nào để xây dựng và triển khai một ứng dụng web trên heroku.</p>

<p>Ý tưởng của ứng dụng đó là chúng ta sẽ dự đoán vật thể trong các bức ảnh. Như chúng ta đã biết, nguồn tài nguyên ảnh thì khá nhiều nhưng rất nhiều ảnh không được gán nhãn. Đây sẽ là một trong những ứng dụng giải quyết được vấn đề nhức nhối là sử dụng sức lao động con người ngồi phân loại và gán nhãn cho hàng nghìn bức ảnh. Hãy để những công việc chân tay cho AI làm. Còn bạn có thể ngồi thư dãn. Ứng dụng này có thể nhận biết được hơn 1000 vật thể khác nhau từ các bức ảnh, khá nhiều phải không nào?</p>

<p>Để giúp dễ hiểu hơn đối với bạn đọc không chuyên về lập trình ứng dụng, bài viết được mình giảm nhẹ các phần kỹ thuật nhất có thể. Nếu bạn chỉ quan tâm đến ứng dụng có thể đọc bắt đầu từ mục 3.3. Nếu bạn đọc quan tâm đến kiến trúc mô hình có thể đọc bắt đầu từ mục đầu tới mục 3.3.</p>

<p>Ngoài ra mình cũng sẽ cung cấp mã nguồn code miễn phí tới các bạn nhằm mục đích hỗ trợ cộng đồng tốt hơn.</p>

<p>Ứng dụng của mình được viết trên ngôn ngữ javascript vì đây là ngôn ngữ có nhiều ưu điểm như dễ học, triển khai ứng dụng nhanh và tương tác đồng thời được với frontend và backend.</p>

<p>Framework mà mình lựa chọn để xây dựng model classification đó là tensorflow js. Đây là một trong những hot trend framework của bác google ở thời điểm hiện tại.</p>

<h1 id="2-tensorflow-js">2. Tensorflow js</h1>

<p>Được bổ sung vào hệ sinh thái tensorflow của google từ 2018, tensorlfow js đã tạo nên một làn sóng trấn động trong cộng đồng AI. Tensorflow JS đã giúp cho việc triển khai các ứng dụng deep learning trên nền tảng website dễ dàng hơn. Ngôn ngữ mà google lựa chọn để build frame work này không phải là C, C++, Java hay những ngôn ngữ mạnh mẽ nào khác mà lại là ngôn ngữ có tính ứng dụng rất thiết thực. Đó chính là javascript. Tại sao lại là javascript? Mình nghĩ lý do chính là javascript rất phổ biến trong cộng đồng web. Việc lựa chọn javascript sẽ thu hút được một cộng đồng các developer web đông đảo. Đồng thời javascript có những frame work mạnh như nodejs hỗ trợ build app và web dường như là realtime. Bạn có thể deploy ứng dụng của mình trong chỉ vài giây, một điều tuyệt vời mà các ngôn ngữ compile như java, C, C++ không làm được. Đồng thời javascript là ngôn ngữ đa năng hoạt động được trên cả frontend và backend nên các developer chỉ cần học 1 ngôn ngữ mà làm được 2 nhiệm vụ. Không hiểu sao mình rất thích javascript vì có thể coi javascript như là một học sinh giỏi học 1 mà biết 2.</p>

<p>Quay lại vấn đề chính. Theo như quảng cáo của trang chủ tensorflow thì tensorflow js có các ưu điểm:</p>

<ul>
  <li>Có thể convert được model từ nhiều format của các deep learning framework khác nhau.</li>
  <li>Có nhiều pretrain model.</li>
  <li>Có một cộng đồng sử dụng rộng.</li>
  <li>Có thể huấn luyện và retrain lại model tensorflow của bạn trên chính website.</li>
  <li>Đóng gói được model của bạn lên front end và truy cập trực tiếp nên tốc độ cao hơn so với call thông qua API.</li>
</ul>

<p>Tóm lại tensorflow js là một lựa chọn khá hữu ích cho những dự án deploy model trên website.</p>

<h1 id="3-model">3. Model</h1>

<h2 id="31-giới-thiệu-về-model-mobilenet">3.1. Giới thiệu về model Mobilenet</h2>

<p>Vì chỉ là demo nên mô hình mà mình sử dụng để deploy ứng dụng này là MobileNet, một mô hình khá nhẹ nên tốc độ load và dự báo nhanh. Tên gọi MobileNet đã nói lên kích thước của mô hình rất nhẹ, phù hợp để triển khai trên các thiết bị di động và IoT.</p>

<p>Mô hình này được nhóm nghiên cứu của google publish năm 2017 (Andrew G. Howard, Menglong Zhu,…).</p>

<p>Điều tuyệt vời khiến mô hình này rất nhẹ là bởi sử dụng kiến trúc tích chập chiều sâu tách biệt (Depthwise Seperable Convolution) có tác dụng giảm thiểu số lượng tham số.</p>

<p>Chúng ta cùng so sánh tích chập chiếu sâu tách biệt có gì khác so với tích chập 2 chiều chuẩn nhé.</p>

<h3 id="311-mạng-tích-chập-2-chiều-chuẩn-standard-2d-convolution">3.1.1. Mạng tích chập 2 chiều chuẩn (Standard 2D Convolution)</h3>

<p>Như chúng ta đã biết, các layer tích chập 2 chiều viết tắt là Conv2D sẽ kết nối đến toàn bộ chiều sâu của layer trước đó. Như vậy kernel sẽ có dạng hình khối <code class="highlighter-rouge">FxFxC_input</code> trong đó <code class="highlighter-rouge">F</code> là kích thước bộ lọc và <code class="highlighter-rouge">C_input</code> là kích thước input channels.</p>

<p>Giả sử chúng ta áp dụng một bộ lọc kích thước <code class="highlighter-rouge">(width x height)</code> = <code class="highlighter-rouge">3 x 3</code> lên hình ảnh input có kích thước <code class="highlighter-rouge">(8 x 8 x 3)</code>. Khi đó áp dụng tích chập 2D chuẩn lên toàn bộ độ sâu của input layer thì bộ lọc phải có độ sâu là 3. Đồng thời, kích thước dạng khối của nó là <code class="highlighter-rouge">(width x height x depths)</code> = <code class="highlighter-rouge">3 x 3 x 3</code>, với <code class="highlighter-rouge">channels</code> bằng chính độ sâu của layer trước.</p>

<p><img src="/assets/images/20200328_TensorflowJS/pic1.png" class="largepic" /></p>

<p><strong>Hình 1</strong>: Kiến trúc mạng tích chập 2 chiều thông thường. Khối đầu tiên là input layer, khối ở giữa là bộ lọc của tích chập 2D chuẩn. Hình vuông cuối cùng là output của kết quả tích chập có kích thước <code class="highlighter-rouge">8 x 8 x 1</code>.</p>

<p>Như vậy theo kiến trúc tích chập này, bộ lọc được mở rộng theo số lượng channels nên chúng ta sẽ phải đầu tư cho mạng số lượng tham số là <code class="highlighter-rouge">3 x 3 x 3 = 27</code>. Nếu áp dụng rất nhiều bộ lọc thì số lượng tham số sẽ lớn hơn rất nhiều.</p>

<p>Chẳng hạn áp dụng 3 bộ lọc, số lượng sẽ là: <code class="highlighter-rouge">(3 x 3 x 3) x 3 = 81</code>.</p>

<h3 id="312-tích-chập-chiều-sâu-tách-biệt-depthwise-separable-convolution">3.1.2. Tích chập chiều sâu tách biệt (Depthwise Separable Convolution)</h3>

<p>Một cải tiến được áp dụng trong MobileNet giúp giảm thiểu số lượng tham số đó là Depthwise Separable Convolution.</p>

<p>Kiến trúc này sẽ không áp dụng bộ lọc lên toàn bộ độ sâu của layer trước đó. Thay vào đó, 1 bộ lọc chỉ được áp dụng trên 1 channel đơn lẻ.</p>

<p>Khi đó số lượng các tham số sẽ được giảm đi đáng kể.</p>

<p>Để dễ hình dung các bạn theo dõi hình bên dưới:</p>

<p><img src="/assets/images/20200328_TensorflowJS/pic2.png" class="largepic" /></p>

<p><strong>Hình 2:</strong> Kiến trúc Depthwise Seperable Convolution. Mục tiêu của chúng ta là cùng áp dụng tích chập để tạo ra output shape <code class="highlighter-rouge">8 x 8 x 1</code> với cùng input như ví dụ 1. Ở hàng đầu tiên là khối input với kích thước <code class="highlighter-rouge">8 x 8 x 3</code>. Ở hàng thứ 2 chúng ta tách khối thành 3 channels input độc lập. Hàng thứ 4 là kết quả sau khi áp dụng tích chập giữa bộ lọc và channel riêng biệt. Tiếp theo hàng thứ 5 ta stack các kết quả lại thành 1 khối kích thước là <code class="highlighter-rouge">8 x 8 x 3</code>. Để thu được output, một bộ lọc tích chập theo chiều sâu kích thước <code class="highlighter-rouge">1 x 1 x 3</code> được áp dụng. Output shape là một khối có kích thước <code class="highlighter-rouge">8 x 8 x 1</code>.</p>

<p>Như vậy với cùng một output shape, Depthwise Separable Convolution chỉ sử dụng tổng cộng là <code class="highlighter-rouge">(3 x 3 x 3)</code> tham số ở bộ lọc hàng thứ 3 và cộng thêm <code class="highlighter-rouge">3</code> tham số ở bộ lọc hàng thứ 6. Kết quả ta sử dụng chỉ 30 tham số so với 81 tham số.</p>

<h2 id="32-kiến-trúc-model-mobilenet">3.2. Kiến trúc model MobileNet</h2>

<p>Về cụ thể kiến trúc của từng layers trong Mobile Net các bạn có thể xem tại bài báo gốc <a href="https://arxiv.org/pdf/1704.04861.pdf">MobileNet: Efficient Convolutional Neural Networks for Mobile Vision
Applications</a>.</p>

<p>Mình có thể liệt kê một số layers như bên dưới:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Model: "mobilenet_1.00_224"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input_1 (InputLayer)         [(None, 224, 224, 3)]     0         
_________________________________________________________________
conv1_pad (ZeroPadding2D)    (None, 225, 225, 3)       0         
_________________________________________________________________
conv1 (Conv2D)               (None, 112, 112, 32)      864       
_________________________________________________________________
conv1_bn (BatchNormalization (None, 112, 112, 32)      128       
_________________________________________________________________
conv1_relu (ReLU)            (None, 112, 112, 32)      0         
_________________________________________________________________
conv_dw_1 (DepthwiseConv2D)  (None, 112, 112, 32)      288       
_________________________________________________________________
conv_dw_1_bn (BatchNormaliza (None, 112, 112, 32)      128       
_________________________________________________________________
conv_dw_1_relu (ReLU)        (None, 112, 112, 32)      0         
_________________________________________________________________
conv_pw_1 (Conv2D)           (None, 112, 112, 64)      2048      
_________________________________________________________________
conv_pw_1_bn (BatchNormaliza (None, 112, 112, 64)      256       
_________________________________________________________________
conv_pw_1_relu (ReLU)        (None, 112, 112, 64)      0         
_________________________________________________________________
conv_pad_2 (ZeroPadding2D)   (None, 113, 113, 64)      0         
_________________________________________________________________
...
_________________________________________________________________
conv_pw_13_bn (BatchNormaliz (None, 7, 7, 1024)        4096      
_________________________________________________________________
conv_pw_13_relu (ReLU)       (None, 7, 7, 1024)        0         
_________________________________________________________________
global_average_pooling2d (Gl (None, 1024)              0         
_________________________________________________________________
reshape_1 (Reshape)          (None, 1, 1, 1024)        0         
_________________________________________________________________
dropout (Dropout)            (None, 1, 1, 1024)        0         
_________________________________________________________________
conv_preds (Conv2D)          (None, 1, 1, 1000)        1025000   
_________________________________________________________________
reshape_2 (Reshape)          (None, 1000)              0         
_________________________________________________________________
predictions (Activation)     (None, 1000)              0         
=================================================================
Total params: 4,253,864
Trainable params: 4,231,976
Non-trainable params: 21,888
</code></pre></div></div>

<p>Để không quá rối mắt, mình đã truncate một số layers trung gian. Bạn có thể simmulate lại kết quả trên tensorlfow:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">applications</span> <span class="n">import</span> <span class="n">MobileNet</span>

<span class="k">model</span> <span class="p">=</span> <span class="n">MobileNet</span><span class="p">(</span><span class="n">weights</span><span class="p">=</span><span class="n">None</span><span class="p">)</span>
<span class="k">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
</code></pre></div></div>

<p>Những dòng (DepthwiseConv2D) là áp dụng tích chập chiều sâu tách biệt. Cách tính số lượng tham số sẽ khác so với tích chập 2 chiều chuẩn. Bạn đọc quan tâm có thể tính thử.</p>

<h2 id="33-convert-model-trên-tensorflow-js">3.3. Convert model trên tensorflow js</h2>

<p>Mô hình MobileNet của tensorlfowjs sẽ hoạt động trực tiếp lên frontend. Do đó tốc độ load và train, predict nhanh hơn so với việc call API. Đồng thời các bạn sẽ thấy được rằng javascript đã chia nhỏ model lớn thành các nodes có kích thước bằng nhau giúp tăng tốc độ xử lý và đồng thời kích thước file cũng nhẹ hơn rất nhiều so với mô hình trên tensorflow. Kích thước model MobileNet gốc của mình khoảng 16 MB nhưng convert sang tensorflow js chỉ còn 5.5 MB.</p>

<p>Trước tiên chúng ta sẽ cần convert model tensorflow để sao cho nó có thể hoạt động được trên javascript. Bạn sẽ cần sử dụng package tensorflow js như sau:</p>

<ul>
  <li>Cài đặt package tensorflowjs</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>!pip install tensorflowjs
</code></pre></div></div>

<ul>
  <li>Load và save pretrain model MobileNet</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">applications</span> <span class="n">import</span> <span class="n">MobileNet</span>

<span class="k">model</span> <span class="p">=</span> <span class="n">MobileNet</span><span class="p">(</span><span class="n">weights</span><span class="p">=</span><span class="s1">'imagenet'</span><span class="p">)</span>
<span class="k">model</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="s1">'mobilenet.h5'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>Convert file <code class="highlighter-rouge">mobilenet.h5</code> về một folder của tensorflow js</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import tensorflowjs as tfjs
import os

os.mkdir('mobilenet_js')
tfjs.converters.save_keras_model(model, 'mobilenet_js')
</code></pre></div></div>

<p>Hoặc bạn cũng có thể gõ trên commandline theo cú pháp:</p>

<p><code class="highlighter-rouge">tensorflowjs_converter --input_format keras \
                       mobilenet.h5 \
                       mobilenet_js</code></p>

<p>Trong đó <code class="highlighter-rouge">--input_format</code> là argument khai báo định dạng model của keras. Hai file <code class="highlighter-rouge">mobilenet.h5</code> là file model gốc cần convert và <code class="highlighter-rouge">mobilenet_js</code> là folder đích sau khi đã convert. Chắc bạn thắc mắc tại sao lại là folder? Như mình đã nói ở trên. Đó là bởi tensorflow javascript phân mô hình thành nhiều nodes có kích thước bằng nhau và đặt chung trong 1 folder. Cơ chế này giúp cho việc load, train, predict nhanh hơn.</p>

<p><img src="https://imgur.com/IP3pgGR.png" class="gigantic" /></p>

<p><strong>Hình 3:</strong> Folder của model tensorflow javascript. File model.json là file chứa kiến trúc của mô hình. Các file <code class="highlighter-rouge">group1-shard1of4.bin</code> là những node của model.</p>

<h1 id="4-giao-diện">4. Giao diện</h1>

<h2 id="41-tạo-giao-diện">4.1. Tạo giao diện</h2>
<p>Sau khi đã có model rồi thì chúng ta sẽ cần tạo một giao diện cho app của chúng ta.</p>

<p>Việc thiết kế giao diện khá tốn thời gian đối với ai chưa làm quen với frontend. Bạn phải vừa biết về html, vừa biết về UI/UX và material design. Mình thì không chuyên về cả 3 thứ này nên làm một giao diện thật đơn giản nhưng đầy đủ chức năng là được.</p>

<p>Đầu tiên hãy hình dung mình app của mình có chức năng gì nhé:</p>

<ul>
  <li>Load model đã được pretrain từ tensorflowjs.</li>
  <li>Upload hình ảnh và hiển thị nó.</li>
  <li>Dự báo hình ảnh.</li>
</ul>

<p>Như vậy là chúng ta sẽ phải có 3 cái nút lần lượt với 3 tác vụ trên là <code class="highlighter-rouge">Upload model, Upload Image và Predict</code>.</p>

<p>Mình sẽ show ra đây cho các bạn dễ hình dung.</p>

<p><img src="https://imgur.com/vokAOS5.png" class="gigantic" /></p>

<p><strong>Hình 4:</strong> Nội dung file index.html.</p>

<p>Trong file index.html chúng ta chú ý đến 2 phần chính đó là các đoạn mã nằm trong thẻ script có tác dụng load CDN packages từ các nguồn open source để sử dụng chúng trên frontend. Ngoài ra bạn cũng cần các button <code class="highlighter-rouge">Upload model, Upload image, predict Image</code>.</p>

<p>Để tương tác với các button ta cần phải đặt tên cho mỗi button bằng mã id, phần này bạn nào làm lập trình thì quá quen thuộc rồi.</p>

<p>Về chức năng của từng thẻ bạn không biết có thể tra trên <a href="https://www.w3schools.com/html/default.asp">w3school</a> nhé.</p>

<h2 id="42-tương-tác-giao-diện">4.2. Tương tác giao diện</h2>

<p>Để tương tác với giao diện ta cần code các hàm trên javascript. Các hàm tương tác giao diện được đặt trong file <code class="highlighter-rouge">js/mobile-net</code>. Phần này đòi hỏi bạn phải hiểu về ngôn ngữ javascript một chút nên bạn xem qua bài <a href="https://www.w3schools.com/js/">w3school Javascript</a> nhé.</p>

<p>Mình sẽ không đi sâu vào giải thích code ở đây mà chỉ nói các chức năng chính của từng hàm:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">loadModel()</code>: Có tác dụng load model thông qua hàm <code class="highlighter-rouge">tf.loadLayersModel()</code> tương đương với tensorflow javascript.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">loadImageLocal()</code>: Upload hình ảnh từ local file.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">predictImage()</code>: Dự báo hình ảnh từ model tensorflow javascript.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">preprocessImage()</code>: Để dự báo hình ảnh, chúng ta cần resize image về đúng kích thước phù hợp với input của model MobileNet là <code class="highlighter-rouge">224x224x3</code>.</p>
  </li>
</ul>

<p>Mình sẽ show ra đây cho bạn nào muốn tìm hiểu.</p>

<pre><code class="javascript">
let model;
let IMAGE_WIDTH = 300;

async function loadModel() {
	console.log("model loading mobilenet model kdfah ...");
	loader = document.getElementById("progress-box");
	load_button = document.getElementById("load-button");
	loader.style.display = "block";
	modelName = "mobilenet";
	model = undefined;
	model = await tf.loadLayersModel('models/mobilenet/model.json');
	if (typeof model !== "undefined") {
		loader.style.display = "none";
		load_button.disabled = true;		
		load_button.innerHTML = "Loaded Model";
		console.log("model loaded..");
	}
};

function loadImageLocal() {
	console.log("Click into selected file image");
  	document.getElementById("select-file-box").style.display = "table-cell";
  	document.getElementById("predict-box").style.display = "table-cell";
  	document.getElementById("prediction").innerHTML = "Click predict to find my label!";
    renderImage(this.files);
};

function renderImage(file) {
  var reader = new FileReader();
  reader.onload = function(event) {
    let output = document.getElementById('test-image');
  	output.src = reader.result;
  	output.width = IMAGE_WIDTH;
  }
  if(event.target.files[0]){
	reader.readAsDataURL(event.target.files[0]);
  }
}

async function predictImage(){
	console.log("Click predict button");
	if (model == undefined) {
		alert("Please load the model first..")
	}
	if (document.getElementById("predict-box").style.display == "none") {
		alert("Please load an image using 'Upload Image' button..")
	}
	let image  = document.getElementById("test-image");
	let tensor = preprocessImage(image, modelName);
	let predictions = await model.predict(tensor).data();
	let results = Array.from(predictions)
		.map(function (p, i) {
			return {
				probability: p,
				className: IMAGENET_CLASSES[i]
			};
		}).sort(function (a, b) {
			return b.probability - a.probability;
		}).slice(0, 5);
	document.getElementById("predict-box").style.display = "block";
	document.getElementById("prediction").innerHTML = "MobileNet prediction <br /><b>" + results[0].className + "</b>";

	var ul = document.getElementById("predict-list");
	ul.innerHTML = "";
	results.forEach(function (p) {
		console.log(p.className + " " + p.probability.toFixed(6));
		var li = document.createElement("LI");
		li.innerHTML = p.className + " " + p.probability.toFixed(6);
		ul.appendChild(li);
	})

	if (typeof predictions !== "undefined"){
		document.getElementById("progress-box").style.display = "none";
	}
}
</code></pre>

<h1 id="5-server">5. Server</h1>

<p>Tương tự như <a href="https://phamdinhkhanh.github.io/2020/03/23/FlaskRestAPI.html">Bài 29 - Xây dựng flask API</a> mà mình đã giới thiệu. Để một ứng dụng hoạt động được thì cần có một server bên dưới. Server tương tác với frontend thông qua API.</p>

<p>Để khởi tạo server mình sử dụng <code class="highlighter-rouge">nodejs</code> thay vì <code class="highlighter-rouge">python</code> vì <code class="highlighter-rouge">nodejs</code> tốc độ cao hơn, đồng thời render kết quả lên frontend mà không cần load và redirect lại trang.</p>

<p>App engine mà mình sử dụng là express, một app engine middleware trung gian giữa server và frontend có tác dụng điều chỉnh các response trước khi gửi cho client. Dành cho bạn nào muốn tìm hiểu thêm về <a href="https://viblo.asia/p/nodejs-tutorial-phan-6-middleware-trong-expressjs-924lJXzWKPM">express</a>.</p>

<p>Code khởi tạo app của mình như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const express = require('express');
let app = express();

app.get("/", cors(corsOptions), (req, res, next) =&gt; {
    res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With,Content-Type, Accept");
	res.sendFile(path.join(__dirname+"/index.html"));
	next();
});
</code></pre></div></div>

<p>app đã khởi tạo một API GET khai báo tại vị trí root trả về trang chủ là <code class="highlighter-rouge">index.html</code>. Tại đây chúng ta sẽ tương tác với giao diện và thực hiện các chức năng upload, dự báo ảnh.</p>

<p>Để server hoạt động thì phần backend chúng ta phải import các packages của nodejs. Các bạn phải cài đặt chúng thông qua <code class="highlighter-rouge">npm</code> (node package manager), một công cụ tương tự như <code class="highlighter-rouge">pip</code> trên python. Tại root directory bạn gõ:</p>

<p><code class="highlighter-rouge">npm install</code></p>

<p>Lệnh này sẽ lookup các thư viện được khai báo trong <code class="highlighter-rouge">package.json</code> (đã được mình định nghĩa sẵn) và cài đặt chúng.</p>

<p>Lưu ý trước đó phải cài <a href="https://www.npmjs.com/get-npm">npm</a>.</p>

<p>Sau khi thiết kế xong server thì bạn đã có thể start nó lên bằng lệnh</p>

<p><code class="highlighter-rouge">node server.js</code></p>

<p>Quá trình này hoàn thành sẽ trả ra câu lệnh trên command line:</p>

<p><code class="highlighter-rouge">Website is Up on PORT 3000 and HOSTNAME development !</code></p>

<p>Bạn truy cập vào link local host <code class="highlighter-rouge">https://127.0.0.1:3000</code> và test các chức năng.</p>

<h1 id="6-deploy-lên-heroku">6. Deploy lên heroku</h1>

<p>Sau khi đã xây dựng thành công model chúng ta sẽ cần deploy website lên một domain webservice. Có khá nhiều domain free khác nhau như heroku, github.io,….</p>

<p>Ở đây mình lựa chọn heroku vì tên miền này hỗ trợ triển khai cho cả website và app. Ngoài ra bạn được miễn phí 500MB cơ sở dữ liệu lưu trữ sanbox.</p>

<p>Vì phần hướng dẫn của bài viết đã khá dài và đêm cũng đã khá muộn. Mặc dù rất muốn viết cho bạn đọc thêm nữa nhưng mình đã khá mệt.</p>

<p>Và đây sẽ là lúc các bạn được rèn luyện tiếng anh của mình bằng cách làm theo hướng dẫn <a href="https://devcenter.heroku.com/categories/deployment">deploy heroku website</a>.</p>

<p>Kết quả cuối cùng bạn thu được là một ứng dụng AI tuyệt vời, có tác dụng phân loại và gãn nhãn thay cho sức lao động của hàng trăm con người:</p>

<p><img src="https://imgur.com/X4rlaTa.png" class="gigantic" /></p>

<p><strong>Hình 5:</strong> Giao diện của ứng dụng web AI.</p>

<p>Bạn có thể trải nghiệm thêm sản phẩm tại: <a href="https://aicode.herokuapp.com/">AIcode heroku app</a></p>

<h1 id="7-tổng-kết">7. Tổng kết:</h1>

<p>Như vậy qua bài viết này mình đã hướng dẫn các bạn triển khai xây dựng một sản phẩm web AI. Các bạn sinh viên có thể sử dụng nó để đưa vào CV của mình khi xin việc. Ngoài ra bạn cũng có thể làm các ứng dụng web AI nho nhỏ để phục vụ cộng đồng rồi đó.</p>

<p>Github code của dự án được để tại <a href="https://github.com/phamdinhkhanh/khanhBlogTurtorial">khanhBlogTurtorial</a>.</p>

<p>Hãy cùng join fanpage của mình để nhận được các open source hay: <a href="https://www.facebook.com/groups/3235479620010379/">AICode</a> và hỗ trợ các lỗi code phát sinh nếu có.</p>

<p>Và subcribe <a href="https://www.facebook.com/TowardDataScience/">KhanhBlog</a> để theo dõi các bài viết về AI của mình nhé.</p>

<h1 id="8-tài-liệu-tham-khảo">8. Tài liệu tham khảo:</h1>

<ol>
  <li><a href="https://www.tensorflow.org/js">Tensorflow js</a></li>
  <li><a href="https://www.w3schools.com/">w3schools</a></li>
  <li><a href="https://aicode.herokuapp.com/">Aicode heroku app</a></li>
  <li><a href="https://devcenter.heroku.com">heroku app</a></li>
</ol>

<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<nav>
  
    <a href="/" >Home</a>
  
    <a href="/about.html" >About</a>
  
    <a href="/blog.html" >Blog</a>
  
</nav>

<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>

<script src="/js/toc.js"></script>
<script src="/js/btnTop.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
});
</script>
				</div>
			</div>
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/logo.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Khanh's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/TowardDataScience">phamdinhkhanh blog</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/3235479620010379/">phamdinhkhanh AICode forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://kaggle.com/phamdinhkhanh">phamdinhkhanh kaggle</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://rpubs.com/phamdinhkhanh">phamdinhkhanh rpub</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://github.com/phamdinhkhanh">phamdinhkhanh github</a></li>
					<br>
					<div class="header">other's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/machinelearningcoban/">machine learning cơ bản facebook</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://forum.machinelearningcoban.com/">machine learning cơ bản forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://machinelearningmastery.com">machine learning mastery</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://viblo.asia">viblosia</a></li>
					<br>
					<div class="header">Khóa học</div>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs109/">Xác suất thống kê(Probability): CS109</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs246/">Bigdata: CS246</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://cs231n.stanford.edu/">Computer vision cơ bản: CS231N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224n/">Natural Language Processing: CS224N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224w/">Khoá phân tích mạng lưới (analysis of network): CS224W</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://web.stanford.edu/class/cs20si/">Khóa học Tensorflow: CS20SI</a></li>
				</nav>
			</div>
		</div>
	</div>
	
</body>
</html>